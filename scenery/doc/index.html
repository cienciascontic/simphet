<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Documentation - Scenery</title>

  <link rel="stylesheet" href="../../sherpa/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/syntaxhighlighter-3.0.83/shThemeDefault.css">

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lodash-2.4.1.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/bootstrap-2.2.2.js"></script>

  <script src="../../sherpa/syntaxhighlighter-3.0.83/shCore.js"></script>
  <script src="../../sherpa/syntaxhighlighter-3.0.83/shBrushJScript.js"></script>
  <script src="../../sherpa/syntaxhighlighter-3.0.83/shBrushXml.js"></script>

  <!-- MathJax config -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/development/scenery.js"></script>

  <script type="text/javascript">
    scenery.Util.polyfillRequestAnimationFrame();

    function docExample( id, draw ) {
      var $container = $( '#' + id );
      var scene = new scenery.Scene( $container );
      draw( scene );
      scene.updateScene();
      var $code = $( '<pre class="brush: js"></pre>' );
      $code.text( draw.toString().match( /\/\*START\*\/((.|\n)*)\/\*END\*\// )[1] );
      $container.after( $code );
    }
  </script>

  <style type="text/css">

    .exampleScene {
      margin: 15px auto;
      border: 1px solid black;
      position: relative;
      left: 0;
      top: 0;
    }

    #sidebar {
      background-color: #eee;
      position: fixed;
      z-index: 10;
      top: 41px; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }

    #apiList {
      background-color: #eee;
      position: relative;
      border: 1px solid #bbb;
      border-left: none;
      padding: 10px;
    }

    .ph2 {
      font-weight: bold;
      font-size: 18px;
    }

    .navlink {
      font-weight: bold;
    }

    .sublink {
      padding-left: 1em;
    }

    .args {
      font-weight: normal;
      font-size: 80%;
    }
  </style>

</head>

<body>
  <div class="navbar navbar-inverse navbar-static-top">
    <div class="navbar-inner">
      <a class="brand" href="../">Scenery</a>
      <ul class="nav">
        <li><a href="../">Home</a></li>
        <li class="active"><a href="../doc">Documentation</a></li>
        <li><a href="../examples">Examples</a></li>
        <li><a href="../tests">Tests</a></li>
      </ul>
      <ul class="nav pull-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">Related <b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a href="../../scenery">Scenery</a></li>
            <li><a href="../../kite">Kite</a></li>
            <li><a href="../../dot">Dot</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>

  <div class="row-fluid">
    <div class="span3"></div>
    <div class="span6">
      <div class="page-header" style="text-align: center;">
        <h1>Scenery Documentation</h1>
      </div>

      <p class="lead" style="color: #a00;">Currently incomplete!</p>

      TODO: coordinate frame notes<br>
      TODO: event handling API documentation<br>
      TODO: use <a href="http://softwaremaniacs.org/soft/highlight/en/">highlight.js</a> for highlighting

    </div>
    <div class="span3"></div>
  </div>

  <div class="row-fluid">
    <div class="span3" id="apiList">
      <div class="ph2"><a href="#api">Scenery API</a></div>

      <a class="navlink" href="#node">Node</a><br>
      <a class="sublink" href="#node-options">(options)</a><br>
      <a class="sublink" href="#node-children">children</a><br>
      <a class="sublink" href="#node-parents">parents</a><br>
      <a class="sublink" href="#node-addChild">addChild</a><br>
      <a class="sublink" href="#node-insertChild">insertChild</a><br>
      <a class="sublink" href="#node-removeChild">removeChild</a><br>
      <a class="sublink" href="#node-addPeer">addPeer</a><br>
      <a class="sublink" href="#node-detach">detach</a><br>
      <a class="sublink" href="#node-cursor">cursor</a><br>
      <a class="sublink" href="#node-mouseArea">mouseArea</a><br>
      <a class="sublink" href="#node-touchArea">touchArea</a><br>
      <a class="sublink" href="#node-clipArea">clipArea</a><br>
      <a class="sublink" href="#node-visible">visible</a><br>
      <a class="sublink" href="#node-pickable">pickable</a><br>
      <a class="sublink" href="#node-opacity">opacity</a><br>
      <a class="sublink" href="#node-matrix">matrix</a><br>
      <a class="sublink" href="#node-translation">translation</a><br>
      <a class="sublink" href="#node-translate">translate</a><br>
      <a class="sublink" href="#node-x">x</a><br>
      <a class="sublink" href="#node-y">y</a><br>
      <a class="sublink" href="#node-rotation">rotation</a><br>
      <a class="sublink" href="#node-rotate">rotate</a><br>
      <a class="sublink" href="#node-rotateAround">rotateAround</a><br>
      <a class="sublink" href="#node-scale">scale</a><br>
      <a class="sublink" href="#node-bounds">bounds</a><br>
      <a class="sublink" href="#node-selfBounds">selfBounds</a><br>
      <a class="sublink" href="#node-childBounds">childBounds</a><br>
      <a class="sublink" href="#node-visibleBounds">visibleBounds</a><br>
      <a class="sublink" href="#node-left">left</a><br>
      <a class="sublink" href="#node-right">right</a><br>
      <a class="sublink" href="#node-top">top</a><br>
      <a class="sublink" href="#node-bottom">bottom</a><br>
      <a class="sublink" href="#node-center">center</a><br>
      <a class="sublink" href="#node-centerX">centerX</a><br>
      <a class="sublink" href="#node-centerY">centerY</a><br>
      <a class="sublink" href="#node-renderer">renderer</a><br>
      <a class="sublink" href="#node-rendererOptions">rendererOptions</a><br>
      <a class="sublink" href="#node-layerSplit">layerSplit</a><br>

      <a class="navlink" href="#scene">Scene</a><br>
      <a class="sublink" href="#scene-options">(options)</a><br>
      <a class="sublink" href="#scene-updateScene">updateScene</a><br>
      <a class="sublink" href="#scene-dispose">dispose</a><br>
      <a class="sublink" href="#scene-renderToCanvas">renderToCanvas</a><br>
      <a class="sublink" href="#scene-canvasSnapshot">canvasSnapshot</a><br>
      <a class="sublink" href="#scene-canvasDataURL">canvasDataURL</a><br>
      <a class="sublink" href="#scene-updateOnRequestAnimationFrame">updateOnRequestAnimationFrame</a><br>
      <a class="sublink" href="#scene-initializeStandaloneEvents">initializeStandaloneEvents</a><br>
      <a class="sublink" href="#scene-initializeFullscreenEvents">initializeFullscreenEvents</a><br>
      <a class="sublink" href="#scene-getDebugHTML">getDebugHTML</a><br>
      <a class="sublink" href="#scene-popupDebug">popupDebug</a><br>

      <a class="navlink" href="#fillable">Fillable</a><br>
      <a class="sublink" href="#fillable-fill">fill</a><br>
      <a class="sublink" href="#fillable-fillPickable">fillPickable</a><br>

      <a class="navlink" href="#strokable">Strokable</a><br>
      <a class="sublink" href="#strokable-stroke">stroke</a><br>
      <a class="sublink" href="#strokable-lineWidth">lineWidth</a><br>
      <a class="sublink" href="#strokable-lineCap">lineCap</a><br>
      <a class="sublink" href="#strokable-lineJoin">lineJoin</a><br>
      <a class="sublink" href="#strokable-lineDash">lineDash</a><br>
      <a class="sublink" href="#strokable-lineDashOffset">lineDashOffset</a><br>
      <a class="sublink" href="#strokable-strokePickable">strokePickable</a><br>

      <a class="navlink" href="#path">Path</a><br>
      <a class="sublink" href="#path-shape">shape</a><br>

      <a class="navlink" href="#image">Image</a><br>
      <a class="sublink" href="#image-image">image</a><br>

      <a class="navlink" href="#text">Text</a><br>
      <a class="sublink" href="#text-options">(options)</a><br>
      <a class="sublink" href="#text-text">text</a><br>
      <a class="sublink" href="#text-font">font</a><br>
      <a class="sublink" href="#text-fontWeight">fontWeight</a><br>
      <a class="sublink" href="#text-fontFamily">fontFamily</a><br>
      <a class="sublink" href="#text-fontStretch">fontStretch</a><br>
      <a class="sublink" href="#text-fontStyle">fontStyle</a><br>
      <a class="sublink" href="#text-fontSize">fontSize</a><br>
      <a class="sublink" href="#text-lineHeight">lineHeight</a><br>
      <a class="sublink" href="#text-direction">direction</a><br>
      <a class="sublink" href="#text-boundsMethod">boundsMethod</a><br>

      <a class="navlink" href="#htmlText">HTMLText</a><br>

      <a class="navlink" href="#dom">DOM</a><br>
      <a class="sublink" href="#dom-element">element</a><br>
      <a class="sublink" href="#dom-interactive">interactive</a><br>

      <a class="navlink" href="#linearGradient">LinearGradient</a><br>
      <a class="sublink" href="#linearGradient-addColorStop">addColorStop</a><br>
      <a class="sublink" href="#linearGradient-setTransformMatrix">setTransformMatrix</a><br>

      <a class="navlink" href="#radialGradient">RadialGradient</a><br>
      <a class="sublink" href="#radialGradient-addColorStop">addColorStop</a><br>
      <a class="sublink" href="#radialGradient-setTransformMatrix">setTransformMatrix</a><br>

      <a class="navlink" href="#pattern">Pattern</a><br>
      <a class="sublink" href="#pattern-setTransformMatrix">setTransformMatrix</a><br>

      <a class="navlink" href="#vbox">VBox</a><br>

      <a class="navlink" href="#rectangle">Rectangle</a><br>
      <a class="sublink" href="#rectangle-rectX">rectX</a><br>
      <a class="sublink" href="#rectangle-rectY">rectY</a><br>
      <a class="sublink" href="#rectangle-rectWidth">rectWidth</a><br>
      <a class="sublink" href="#rectangle-rectHeight">rectHeight</a><br>

      <a class="navlink" href="#circle">Circle</a><br>
      <a class="sublink" href="#circle-radius">radius</a><br>

      <a class="navlink" href="#line">Line</a><br>
      <a class="sublink" href="#line-x1">x1</a><br>
      <a class="sublink" href="#line-y1">x1</a><br>
      <a class="sublink" href="#line-x2">x2</a><br>
      <a class="sublink" href="#line-y2">y2</a><br>
      <a class="sublink" href="#line-p1">p1</a><br>
      <a class="sublink" href="#line-p2">p2</a><br>

      <a class="navlink" href="#font">Font</a><br>
      <a class="sublink" href="#font-font">font</a><br>
      <a class="sublink" href="#font-family">family</a><br>
      <a class="sublink" href="#font-weight">weight</a><br>
      <a class="sublink" href="#font-stretch">stretch</a><br>
      <a class="sublink" href="#font-style">style</a><br>
      <a class="sublink" href="#font-size">size</a><br>
      <a class="sublink" href="#font-lineHeight">lineHeight</a><br>

      <a class="navlink" href="#color">Color</a><br>
      <a class="sublink" href="#color-red">red</a><br>
      <a class="sublink" href="#color-green">green</a><br>
      <a class="sublink" href="#color-blue">blue</a><br>
      <a class="sublink" href="#color-alpha">alpha</a><br>
      <a class="sublink" href="#color-toCSS">toCSS</a><br>

      <a class="navlink" href="#event">Event</a><br>

      <a class="navlink" href="#pointer">Pointer</a><br>

      <a class="navlink" href="#mouse">Mouse</a><br>

      <a class="navlink" href="#touch">Touch</a><br>

      <a class="navlink" href="#pen">Pen</a><br>

      <a class="navlink" href="#trail">Trail</a><br>

    </div>
    <div class="span6">
      <h2 id="tutorials">Tutorials</h2>

      <p>If you are just starting out, see the <a href="a-tour-of-scenery.html">Tour of Scenery</a></p>
      <p>See the <a href="user-input.html">user input documentation</a> for handling user-generated events.</p>
      
      <h2 id="get-the-code">Get the code</h2>
      
      <p>
        Scenery depends on a few other libraries, and needs to have them checked out as siblings. It is recommended to
        place all of these inside a containing directory. Make sure you have <a href="https://help.github.com/articles/set-up-git">git</a> installed, then run:
      </p>
      
      <pre>
git clone https://github.com/phetsims/sherpa.git
git clone https://github.com/phetsims/chipper.git
git clone https://github.com/phetsims/assert.git
git clone https://github.com/phetsims/phet-core.git
git clone https://github.com/phetsims/dot.git
git clone https://github.com/phetsims/kite.git
git clone https://github.com/phetsims/scenery.git</pre>
      
      <p>
        For some examples and tests, and to build a custom version, you'll need to install <a href="http://nodejs.org/">node.js</a>, and <a href="https://github.com/gruntjs/grunt-cli">grunt-cli</a>. Then,
      </p>
      
      <pre>
cd scenery
npm install
grunt</pre>
      
      <p>
        You will now have the built files under build/
      </p>

      <h2 id="dependencies">Dependencies</h2>

      <strong>External</strong> dependencies (please provide these in your page before loading Scenery):
      <ul>
        <li><a href="http://jquery.com/">jQuery</a> for parts of DOM manipulation.</li>
        <li><a href="http://lodash.com/">Lo-Dash</a> for utility functions, as a replacement for <a href="http://underscorejs.org/">Underscore.js</a>.</li>
        <li>[optional] <a href="https://code.google.com/p/canvg/">Canvg</a>, for supporting SVG &#8594; Canvas operations, like <a href="#scene-renderToCanvas">scene.renderToCanvas</a></li>
      </ul>

      <strong>Internal</strong> dependencies:
      <ul>
        <li><a href="https://github.com/phetsims/assert">assert</a> for assertion handling. If you want assertions different from the defaults, include <a href="https://github.com/phiggins42/has.js/">has.js</a>.</li>
        <li><a href="https://github.com/phetsims/phet-core">phet-core</a> for other utility functions.</li>
        <li><a href="../../dot">Dot</a> for math.</li>
        <li><a href="../../kite">Kite</a> for shapes.</li>
      </ul>

      <h2 id="debugging">Debugging</h2>

      <p>
        If has.js is included, Scenery assertions can be enabled or disabled. Performance can be significantly decreased if all assertions are enabled.
      </p>
      <p>
        To enable all assertions for debugging, run the following (assuming has.js has been loaded):
      </p>
      <pre class="brush: js">
has.add( 'assert.basic', function() { return true; } );
has.add( 'assert.slow', function() { return true; } );
      </pre>
      <p>
        or to disable assertions:
      </p>
      <pre class="brush: js">
has.add( 'assert.basic', function() { return false; } );
has.add( 'assert.slow', function() { return false; } );
      </pre>

      <h2 id="api">Scenery API</h2>

      <h3 id="node" class="section">Node</h3>

      <p>
        A default node can be created with <code>new scenery.Node()</code>, but usually a parameter object is
        given, for example <code>new scenery.Node( { x: 20, y: 100 } )</code>. Below are all of the available
        parameter object options:
      </p>

      <h4 id="node-options">Node Options</h4>
      A Node (and Node subtypes) have the following parameter object options available, executed in in the order listed.

      <ul>
        <li><a href="#node-children">children</a>: A list of children to add (in order)</li>
        <li><a href="#node-cursor">cursor</a>: Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.</li>
        <li><a href="#node-visible">visible</a>: If false, this node (and its children) will not be displayed (or get input events)</li>
        <li><a href="#node-pickable">pickable</a>: If false, this node (and its children) will not get input events</li>
        <li><a href="#node-opacity">opacity</a>: From 0 (transparent) to 1 (opaque)</li>
        <li><a href="#node-matrix">matrix</a>: Sets the transform matrix of the node to the specified <a href="../../dot/doc#matrix3">dot.Matrix3</a> value</li>
        <li><a href="#node-translation">translation</a>: Sets the translation of the node to either the specified <a href="../../dot/doc#vector2">dot.Vector2</a> value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )</li>
        <li><a href="#node-x">x</a>: Sets the x-translation of the node</li>
        <li><a href="#node-y">y</a>: Sets the y-translation of the node</li>
        <li><a href="#node-rotation">rotation</a>: Sets the rotation of the node in radians</li>
        <li><a href="#node-scale">scale</a>: Sets the scale of the node. Supports either a number (same x-y scale), or a <a href="../../dot/doc#vector2">dot.Vector2</a> / object with ob.x and ob.y to set the scale for each axis independently</li>
        <li><a href="#node-left">left</a>: Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-right">right</a>: Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-top">top</a>: Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-bottom">bottom</a>: Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-center">center</a>: Sets the translation so that the center of the bounding box (in the parent coordinate frame) is at the specified <a href="../../dot/doc#vector2">dot.Vector2</a> value</li>
        <li><a href="#node-centerX">centerX</a>: Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-centerY">centerY</a>: Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value</li>
        <li><a href="#node-renderer">renderer</a>: Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)</li>
        <li><a href="#node-rendererOptions">rendererOptions</a>: Parameter object that is passed to the created layer, and can affect how the layering process works.</li>
        <li><a href="#node-layerSplit">layerSplit</a>: Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.</li>
        <li><a href="#node-mouseArea">mouseArea</a>: Shape (in local coordinate frame) that overrides the 'hit area' for mouse input.</li>
        <li><a href="#node-touchArea">touchArea</a>: Shape (in local coordinate frame) that overrides the 'hit area' for touch input.</li>
        <li><a href="#node-clipArea">clipArea</a>: Shape (in local coordinate frame) that causes any graphics outside of the shape to be invisible (for the node and any children).</li>
      </ul>

      <h4 id="node-children">node.children</h4>
      <p>
        <code>node.children</code> is a getter/setter linked to <code>node.getChildren()</code> and <code>node.setChildren( children )</code>.
        This will return a copy of node's array of children, in rendering
        order (later children render above previous children). Making changes to the returned array will not change node's children.
      </p>
      <p>
        This can also be used when creating a Node:
      </p>
      <div id="example-children" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-children', function( scene ) {
/*START*/
scene.addChild( new scenery.Node( {
  // an array of children can be specified, so no
  // reference to the container node is needed
  children: [
    // gray rectangle on the left
    new scenery.Path( kite.Shape.rectangle( 0, 0, 64, 64 ), {
      fill: '#aaa'
    } ),

    // later nodes in the array will show up on top
    // of previous nodes
    new scenery.Text( 'Children', {
      font: '20px sans-serif',
      centerX: 64,
      centerY: 32
    } )
  ]
} ) );
/*END*/ } );
      </script>

      <h4 id="node-parents">node.parents</h4>
      <p>
        <code>node.parents</code> or <code>node.getParents()</code> will return an array of parent nodes, but <strong>order is not significant</strong>.
      </p>

      <h4 id="node-addChild">node.addChild( <span class="args">childNode</span> )</h4>
      <p>
        Appends childNode to node's list of children. childNode will be displayed above node and node's other children.
      </p>

      <h4 id="node-insertChild">node.insertChild( <span class="args">index, childNode</span> )</h4>
      <p>
        Inserts childNode into node's children at the specified index. <code>node.insertChild( 0, childNode )</code> will make childNode the first child, and
        <code>node.insertChild( node.children.length, childNode )</code> is the same as <code>node.addChild( childNode )</code>.
      </p>

      <h4 id="node-removeChild">node.removeChild( <span class="args">childNode</span> )</h4>
      <p>
        Removes childNode from node's children.
      </p>

      <h4 id="node-addPeer">node.addPeer( <span class="args">element, options</span> )</h4>
      <p>
        Adds an accessibility peer described by the element and options to the tab order (handled for each instance). <code>element</code> can be either
        a DOM element (it is used directly, and tabindex is set on it), or an HTML string (which will be duplicated for each instance). The peer can be focused,
        and peers can be modified to reflect the current state of the node.
      </p>
      <p>
        Currently if it exists, options.click is called when the peer is activated by the keyboard while focused.
      </p>
      <p>
        For instance, a toggle button or checkbox should generally use <code>'&lt;input type="checkbox"&gt;'</code> for its element.
      </p>

      <h4 id="node-detach">node.detach()</h4>
      <p>
        Removes this node from all of its parents.
      </p>

      <h4 id="node-cursor">node.cursor</h4>
      <p>
        <code>node.cursor</code> is a getter/setter linked to <code>node.getCursor()</code> and <code>node.setCursor( cursor )</code>.
        By default it is null (default cursor), but this can be set to
        the string for any <a href="https://developer.mozilla.org/en-US/docs/CSS/cursor">CSS cursor value</a>, and some extra Scenery-specified ones below. There is
        <a href="../examples/cursors.html">a cursor example page</a> that demos a number of available cursors.
      </p>
      <p>
        The cursor is updated whenever <a href="#scene-updateCursor">scene.updateCursor</a> or <a href="#scene-updateScene">scene.updateScene</a> is called, and event initialization like <a href="#scene-initializeStandaloneEvents">scene.initializeStandaloneEvents</a> should be added so Scenery can track the mouse input.
      </p>
      <p>
        There are some Scenery-specific cursor values that can be set:
      </p>
      <ul>
        <li>
          scenery-grab-pointer: attempts to use browser-prefixed 'grab' values (newer), but falls back to the 'pointer' if not available
        </li>
        <li>
          scenery-grabbing-pointer: attempts to use browser-prefixed 'grabbing' values (newer), but falls back to the 'pointer' if not available
        </li>
      </ul>
      <div id="example-cursor" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-cursor', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( kite.Shape.regularPolygon( 6, 25 ), {
  x: 64, y: 32,
  fill: '#88f',
  cursor: 'pointer', // classic hand
  pickable: true // since otherwise it would be pruned from hit testing
} ) );
/*END*/
// event initialization needed for cursor to work
scene.initializeStandaloneEvents();

// and update on every frame
scene.updateOnRequestAnimationFrame();
} );
      </script>

      <h4 id="node-mouseArea">node.mouseArea</h4>
      <p>
        Sets an alternative hit region when receiving mouse events. Useful for when there
        are gaps between children which should still respond to the event.
      </p>
      <p>
        Accepts both arbitrary shapes (<a href="../../kite/doc#shape">Shape</a>) and bounding boxes (<a href="../../dot/doc#bounds2">Bounds2</a>).
      </p>
      <p>
        The mouse area supersedes the hit regions for mouse events of the node itself and its descendants.
        Setting mouseArea on a Node will cause it to either return no hit (for it or its children when outside of the mouseArea) or this Node as an event target.
      </p>

      <h4 id="node-touchArea">node.touchArea</h4>
      <p>
        Sets an alternative hit region when receiving touch events. Useful for expanding
        where the user can touch controls.
      </p>
      <p>
        Accepts both arbitrary shapes (<a href="../../kite/doc#shape">Shape</a>) and bounding boxes (<a href="../../dot/doc#bounds2">Bounds2</a>).
      </p>
      <p>
        The touch area supersedes the hit regions for touch events of the node itself and its descendants.
        Setting touchArea on a Node will cause it to either return no hit (for it or its children when outside of the touchArea) or this Node as an event target.
      </p>

      <h4 id="node-clipArea">node.clipArea</h4>
      <p>
        <code>node.clipArea</code> is a getter/setter linked to <code>node.getClipArea()</code> and <code>node.setClipArea( shape )</code>.
        Default is <code>null</code> (no clipping), but when the clipArea is set to a <a href="../../kite/doc#shape">Shape</a>, anything outside
        of the clip area Shape (in the node's local coordinate frame) is not displayed. This clipping affects both the node's own display, and the display of any
        of its children.
      </p>
      <p>
        clipArea currently does not affect DOM layers, and the general case can't be added in (CSS clip only allows rectangles currently).
      </p>
      <p>
        clipArea is not currently compatible with CSS-transformed SVG rendering if the clipArea is on an ancestor of the CSS-transformed Node.
      </p>
      <p>
        clipArea affects the bounds and localBounds of the Node, and pointers are not considered "over" a node if they are outside of its clipArea.
      </p>
      <div id="example-clipArea" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-clipArea', function( scene ) {
  scene.renderer = 'svg';
/*START*/
scene.addChild( new scenery.Circle( 28, {
  fill: 'black',
  stroke: 'red',
  lineWidth: 5,
  x: 38, y: 38,
  clipArea: kite.Shape.roundRect( -32, -32, 50, 50, 10, 10 )
} ) );
/*END*/
} );
      </script>

      <h4 id="node-visible">node.visible</h4>
      <p>
        <code>node.visible</code> is a getter/setter linked to <code>node.isVisible()</code> and <code>node.setVisible( boolean )</code>.
        Nodes are by default visible, but when invisible they will not
        be displayed and will not be pickable (no input events will be targeted to them).
      </p>

      <h4 id="node-pickable">node.pickable</h4>
      <p>
        <code>node.pickable</code> is a getter/setter linked to <code>node.isPickable()</code> and <code>node.setPickable( boolean | null )</code>.
        Pickable can take three values:
      </p>
      <ul>
        <li>
          null: (default) pass-through behavior. Hit-testing will prune this subtree if there are no ancestors/descendants with either pickable: true set
          or with any input listeners
        </li>
        <li>
          false: Hit-testing is pruned, nothing under a pickable: false will respond to events or be picked
        </li>
        <li>
          true: Hit-testing will not be pruned in this subtree, except for pickable: false cases.
        </li>
      </ul>
      <p>
        Hit testing is accomplished mainly with <a href="#node-trailUnderPointer">node.trailUnderPointer</a> and <a href="#node-trailUnderPoint">node.trailUnderPoint</a>,
        following the above rules. Nodes that are not pickable (pruned) will not have input events targeted to them.
      </p>
      <p>
        Thus in order for a Node (really, a Trail) to be able to receive input events:
      </p>
      <ol>
        <li>If the node or one of its ancestors has pickable: false OR is invisible, the node <strong>will not</strong> receive events or hit testing</li>
        <li>If the node or one of its ancestors or descendants is pickable: true OR has an input listener attached, it <strong>will</strong> receive events or hit testing</li>
        <li>Otherwise, it <strong>will not</strong> receive events or hit testing</li>
      </ol>
      <p>
        This is useful for semi-transparent overlays or other visual elements that should be displayed but should not prevent objects below from being
        manipulated by user input, and the default 'null' value is used to increase performance by ignoring areas that don't need user input.
      </p>

      <h4 id="node-opacity">node.opacity</h4>
      <p>
        <code>node.opacity</code> is a getter/setter linked to <code>node.getOpacity()</code> and <code>node.setOpacity( opacity )</code>.
        Opacity should be in the inclusive range of 0 to 1, where 0 is fully transparent, and 1 is fully opaque. <code>opacity</code> controls not only
        the opacity (alpha) of the node itself, but also all of its children.
      </p>
      <div id="example-opacity" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-opacity', function( scene ) {
/*START*/
scene.addChild( new scenery.Rectangle( 0, 12, 64, 20, { fill: '#000' } ) );
var circle = kite.Shape.circle( 0, 0, 30 );
scene.addChild( new scenery.Node( {
  opacity: 0.5,
  children: [
    new scenery.Path( circle, { x: 12, y: 22, fill: '#f00' } ),
    new scenery.Path( circle, { x: 52, y: 22, fill: '#00f' } )
  ]
} ) );
/*END*/
} );
      </script>

      <h4 id="node-matrix">node.matrix</h4>
      <p>
        <code>node.matrix</code> (<code>node.getMatrix()</code>, <code>node.setMatrix( matrix )</code>) gets or sets the transformation matrix associated with the
        node, of type <a href="../../dot/doc#matrix3">dot.Matrix3</a>.
      </p>

      <h4 id="node-translation">node.translation</h4>
      <p>
        Getting the translation: <code>node.translation</code> or <code>node.getTranslation()</code>. It always returns a <a href="../../dot/doc#vector2">dot.Vector2</a> instance representing
        the translation part of the node's transform. See <a href="../../dot/doc#matrix3-getTranslation">dot.Matrix3.getTranslation</a> for more information.
      </p>
      <p>
        Setting the translation: <code>node.translation = translation</code>, <code>node.setTranslation( translation )</code> or <code>node.setTranslation( x, y )</code>.
        In both instances, <code>translation</code> can be either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object literal like <code>{ x: 5, y: 10 }</code>.
      </p>

      <h4 id="node-translate">node.translate( <span class="args">x, y</span> )</h4>
      <p>
        Translates the node relatively by <code>x</code> and <code>y</code>. In addition to <code>node.translate( x, y )</code>, <code>node.translate( translation )</code>
        can be used, where <code>transform</code> is either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object like <code>{ x: 5, y: 10 }</code>
      </p>

      <h4 id="node-x">node.x</h4>
      <p>
        <code>node.x</code> gets or sets the node's x-translation with <code>node.getX()</code> and <code>node.setX( x )</code>. Accessing <code>node.x</code> is equivalent
        to <code>node.translation.x</code>, and setting <code>node.x</code> is equivalent to <code>node.setTranslation( x, node.y )</code>.
      </p>

      <h4 id="node-y">node.y</h4>
      <p>
        <code>node.y</code> gets or sets the node's y-translation with <code>node.getY()</code> and <code>node.setY( y )</code>. Accessing <code>node.y</code> is equivalent
        to <code>node.translation.y</code>, and setting <code>node.y</code> is equivalent to <code>node.setTranslation( node.x, y )</code>.
      </p>

      <h4 id="node-rotation">node.rotation</h4>
      <p>
        <code>node.rotation</code> gets or sets the node's rotation with <code>node.getRotation()</code> and <code>node.setRotation( radians )</code>. All rotations are
        handled in radians ($\pi$ is a 180-degree rotation). If you wish to rotate a node by a specific rotation
        (instead of setting its rotation), use <a href="#node-rotate">node.rotate</a>
      </p>

      <h4 id="node-rotate">node.rotate( <span class="args">radians, [prepend]</span> )</h4>
      <p>
        Rotates the node's transform. By default the rotation is appended to the node's transform, but the optional <code>prepend</code> boolean flag can be added for the rotation
        to be prepended to the node's transform.
      </p>

      <h4 id="node-rotateAround">node.rotateAround( <span class="args">point, angle</span> )</h4>
      <p>
        Rotates the node by <code>angle</code> in radians around the <a href="../../dot/doc#vector2">dot.Vector2</a> <code>point</code>. <code>point</code> should be in the node's parent coordinate frame.
      </p>

      <h4 id="node-scale">node.scale( <span class="args">x, y, [prepend]</span> )</h4>
      <p>
        Scales the node in each axis. By default the scale is appended to the node's transform, but the optional <code>prepend</code> boolean flag can be added for the
        scale to be prepended to the node's transform.
      </p>
      <p>
        <code>node.scale( s )</code> will scale by <code>s</code> in both dimensions, and is equivalent to <code>node.scale( s, s )</code>
      </p>

      <h4 id="node-bounds">node.bounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (and its children) in the parent coordinate frame. Also available with <code>node.getBounds()</code>. It includes all children, regardless
        of whether they are visible or not.
        <!-- TODO: add an example -->
      </p>

      <h4 id="node-selfBounds">node.selfBounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (without its children) in the local coordinate frame. Also available with <code>node.getSelfBounds()</code>.
        <!-- TODO: add an example -->
      </p>

      <h4 id="node-childBounds">node.childBounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node's children (without include the node's selfBounds) in the local coordinate frame. Also available with <code>node.getChildBounds()</code>.
        <!-- TODO: add an example -->
      </p>

      <h4 id="node-visibleBounds">node.visibleBounds</h4>
      <p>
        Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (and its children) in the parent coordinate frame. Also available with <code>node.getVisibleBounds()</code>. Unlike <a href="#node-bounds">bounds</a>, this includes only descendants which are visible. It is not tracked, so each call will
        need to traverse the subtree to get the bounds.
        <!-- TODO: add an example -->
      </p>

      <h4 id="node-left">node.left</h4>
      <p>
        <code>node.left</code> gets or sets the left bound (minimum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getLeft()</code> and <code>node.setLeft( x )</code>. Setting this left bound effectively translates the node horizontally.
      </p>

      <h4 id="node-right">node.right</h4>
      <p>
        <code>node.right</code> gets or sets the right bound (maximum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getRight()</code> and <code>node.setRight( x )</code>. Setting this right bound effectively translates the node horizontally.
      </p>

      <h4 id="node-top">node.top</h4>
      <p>
        <code>node.top</code> gets or sets the top bound (minimum y value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getTop()</code> and <code>node.setTop( y )</code>. Setting this top bound effectively translates the node vertically.
      </p>

      <h4 id="node-bottom">node.bottom</h4>
      <p>
        <code>node.bottom</code> gets or sets the bottom bound (maximum y value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getBottom()</code> and <code>node.setBottom( y )</code>. Setting this bottom bound effectively translates the node vertically.
      </p>

      <h4 id="node-center">node.center</h4>
      <p>
        <code>node.center</code> gets or sets the center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getCenter()</code> and <code>node.setCenter( center )</code>, which both handle the center as a
        <a href="../../dot/doc#vector2">dot.Vector2</a> instance. Setting center effectively translates the node.
      </p>

      <h4 id="node-centerX">node.centerX</h4>
      <p>
        <code>node.centerX</code> gets or sets the horizontal center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getCenterX()</code> and <code>node.setCenterX( x )</code>. Setting centerX effectively translates the node horizontally.
      </p>

      <h4 id="node-centerY">node.centerY</h4>
      <p>
        <code>node.centerY</code> gets or sets the vertical center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
        <code>node.getCenterY()</code> and <code>node.setCenterY( y )</code>. Setting centerY effectively translates the node vertically.
      </p>

      <h4 id="node-renderer">node.renderer</h4>
      <p>
        <code>node.renderer</code> gets or sets the preferred rendering backend for the node (and children) using <code>node.getRenderer()</code> or <code>node.setRenderer( renderer )</code>.
      </p>
      <p>
        It will always return a <a href="#renderer">Renderer</a> object back, but setting the renderer can be done either with an <a href="#renderer">Renderer</a> reference or
        a string (either <code>'canvas'</code>, <code>'svg'</code>, <code>'dom'</code> or <code>'webgl'</code>). Manually specifying a renderer may preclude future
        performance/quality tradeoffs from being automatically made.
      </p>
      <p>
        Setting a renderer will have this node and its children use that renderer if they support it. This may be impossible (for instance, <a href="#path">Paths</a> do not support the <code>'dom'</code> renderer, and <a href="#dom">DOM nodes</a> do not support the <code>'canvas'</code> renderer).
      </p>
      <p>
        This renderer (if non-null) will override any renderers set on ancestor nodes. Effectively, a node's renderer will be decided by whatever the closest ancestor
        renderer that is compatible, or the scene default.
      </p>
      <p>
        <code>node.hasRenderer()</code> is a convenience function to determine if this is set on the node.
      </p>

      <h4 id="node-rendererOptions">node.rendererOptions</h4>
      <p>
        <code>node.rendererOptions</code> gets or sets options for the specified <a href="#node-renderer">renderer</a> using
        <code>node.getRendererOptions()</code> or <code>node.setRendererOptions( renderer )</code>.
        Setting <a href="#node-rendererOptions">rendererOptions</a> without setting <a href="#node-renderer">renderer</a> will have no effect, and may in future
        versions throw an error. If this option and the <a href="#node-renderer">renderer</a> is set, this node will have layer boundaries inserted before and after.
        <!-- TODO: docs of rendererOptions for different layers -->
      </p>

      <h4 id="node-layerSplit">node.layerSplit</h4>
      <p>
        Setter backed by <code>node.setLayerSplit( boolean )</code> that, when to true will cause anything rendered before or after to be in a
        separate layer from this node and its children.
      </p>


      <h3 id="scene" class="section">Scene</h3>
      <p>
        The Scene is the "entry point" of a scene graph. Scene extends Node, so all of its methods and options
        are inherited, see <a href="#node">Node</a> above.
        A scene is created with <code>new scenery.Scene( $container, [options] )</code>, where <code>$container</code>
        is a block-level DOM element (typically a div) wrapped with jQuery that all scene graphics
        (Canvas, SVG, etc.) are placed within.
        This element must be a positioned element (non-'static' CSS position, see
        the <a href="https://developer.mozilla.org/en-US/docs/CSS/position">MDN docs</a>), and should have a set width and height.
      </p>

      <h4 id="scene-options">Scene Options</h4>
      A Scene has the following options for the parameter object, in addition to all of <a href="#node-options">Node's options</a>:

      <ul>
        <li><a href="#scene-allowSceneOverflow">allowSceneOverflow</a> (default false): usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow</li>
        <li><a href="#scene-allowCSSHacks">allowCSSHacks</a> (default true): applies styling that prevents mobile browser graphical issues</li>
        <li><a href="#scene-allowDevicePixelRatioScaling">allowDevicePixelRatioScaling</a> (default false): allows underlying canvases (Canvas, WebGL) to increase in size to maintain sharpness on high-density displays</li>
        <li><a href="#scene-enablePointerEvents">enablePointerEvents</a> (default true): allows pointer events / MSPointerEvent to be used on supported platforms.</li>
        <li><a href="#scene-preferredSceneLayerType">preferredSceneLayerType</a> (default ???): sets the preferred type of layer to be created if there are multiple options.</li>
        <li><a href="#scene-width">width</a> (default currentWidth): override the main container's width</li>
        <li><a href="#scene-height">height</a> (default currentHeight): override the main container's height</li>
      </ul>

      <h4 id="scene-updateScene">scene.updateScene()</h4>
      <p>
        This redraws and/or repositions whatever rendering backends are being used to display the scene.
        It should be called whenever the scene's display should reflect new changes, generally on each
        <a href="https://developer.mozilla.org/en-US/docs/DOM/window.requestAnimationFrame">requestAnimationFrame</a>.
      </p>

      <h4 id="scene-dispose">scene.dispose()</h4>
      <p>
        Disposes of all of the scene's necessary resources and listeners, so that it should be able to be
        garbage collected if no more references are to the Scene. Call this once you no longer need a scene.
      </p>

      <h4 id="scene-renderToCanvas">scene.renderToCanvas( <span class="args">canvas, context, callback</span> )</h4>
      <p>
        Renders all applicable layers that support Canvas output to the specified <code>canvas</code> (with
        the specified <code>context</code>). The <code>context</code> is specified in addition to the canvas
        to support any custom parameters that were given in context creation.
      </p>
      <p>
        <code>callback()</code> is called once the Scene is fully rendered to the canvas. Generally this is
        immediate (if the layers are canvas/webgl), or delayed (if a layer contains SVG content). Including
        the <a href="https://code.google.com/p/canvg/">Canvg</a> library is necessary for rendering SVG
        content to Canvas.
      </p>
      <p>
        DOM content is currently not supported for renderToCanvas.
      </p>

      <h4 id="scene-canvasSnapshot">scene.canvasSnapshot( <span class="args">callback</span> )</h4>
      <p>
        Asynchronously draws the scene to a canvas with the same size as the scene
        (using <a href="#scene-renderToCanvas">renderToCanvas</a>, and calls <code>callback( canvas, imageData )</code>
        once it is fully written. <code>imageData</code> is of type <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#imagedata">ImageData</a>, from the Canvas specification.
      </p>
      <p>
        If any origin-dirty content (like cross-domain images without <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>) are included in the Scene, this operation will throw a security error.
      </p>

      <h4 id="scene-canvasDataURL">scene.canvasDataURL( <span class="args">callback</span> )</h4>
      <p>
        Asynchronously draws the scene to an image (using <a href="#scene-canvasSnapshot">scene.canvasSnapshot</a>),
        and calls <code>callback( dataURL )</code> with the
        <a href="https://developer.mozilla.org/en-US/docs/data_URIs">data URI</a> for the image. Generally
        this is a PNG. Does not support origin-dirty content (see <a href="#scene-canvasSnapshot">canvasSnapshot</a>)
        inside the scene.
      </p>

      <h4 id="scene-updateOnRequestAnimationFrame">scene.updateOnRequestAnimationFrame( <span class="args">[element]</span> )</h4>
      <p>
        A simple way of setting up <a href="#scene-updateScene">scene.updateScene</a> to be called using
        requestAnimationFrame. More advanced applications will want to handle this themselves.
      </p>

      <h4 id="scene-initializeStandaloneEvents">scene.initializeStandaloneEvents()</h4>
      <p>
        Attaches event listeners onto the scene's containing block-level element, and forwards them to
        the scene's input event handling system. This or <a href="scene-initializeFullscreenEvents">initializeFullscreenEvents</a> is necessary for cursor handling and input/pointer events.
      </p>

      <h4 id="scene-initializeFullscreenEvents">scene.initializeFullscreenEvents()</h4>
      <p>
        Attaches event listeners onto the containing document, and forwards them to
        the scene's input event handling system. This or <a href="scene-initializeStandaloneEvents">initializeStandaloneEvents</a> is necessary for cursor handling and input/pointer events.
      </p>
      <p>
        This may call <a href="https://developer.mozilla.org/en-US/docs/DOM/event.preventDefault">preventDefault</a>
        on events unrelated to the scene, so <a href="scene-initializeFullscreenEvents">initializeFullscreenEvents</a>
        should only be used when the scene takes up the entire screen.
      </p>

      <h4 id="scene-getDebugHTML">scene.getDebugHTML()</h4>
      <p>
        Returns an HTML string of debugging information that shows all of the nodes (their constructor type
        names), and all layering information.
      </p>

      <h4 id="scene-popupDebug">scene.popupDebug()</h4>
      <p>
        Pops the information from <a href="#scene-getDebugHTML">getDebugHTML</a> into a new window.
      </p>

      <h3 id="fillable" class="section">Fillable</h3>
      <p>
        A mix-in for <a href="#node">Node</a> subtypes that can be filled with a color/gradient/pattern.
      </p>

      <h4 id="fillable-fill">fill</h4>
      <p>
        <a href="#fillable">Fillable</a> nodes provide a single <code>node.fill</code> getter and setter
        that uses <code>node.getFill()</code> and <code>node.setFill( fill )</code>. <code>node.hasFill()</code>
        is also available as a quick check, and a null fill is interpreted as not having a fill.
      </p>
      <p>
        <code>fill</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>), a
        <a href="#color">Color</a> object, or an instance of a
        <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
        <a href="#pattern">Pattern</a>.
      </p>
      <p>
        If a <a href="#color">Color</a> object is used for a fill, any changes to the Color object will update this node.
      </p>
      
      <h4 id="fillable-fillPickable">fillPickable</h4>
      <p>
        <code>node.fillPickable</code> is a getter/setter linked to <code>node.isFillPickable()</code> and <code>node.setFillPickable( boolean )</code>.
        <a href="#path">Paths</a> or other <a href="#fillable">Fillable</a> objects will be considered to be under a <a href="#pointer">Pointer</a> when
        it is over the region where the fill is painted. This defaults to true.
      </p>
      <p>
        NOTE: <a href="#text">Text</a> nodes currently do not respect this setting, since there is no easy/fast way of determining whether a point is inside
        or outside of a Text node's painted region.
      </p>

      <h3 id="strokable" class="section">Strokable</h3>
      <p>
        A mix-in for <a href="#node">Node</a> subtypes that can be stroked (outlined) along a border with a color/gradient/pattern.
      </p>

      <h4 id="strokable-stroke">stroke</h4>
      <p>
        <code>node.stroke</code> is a getter and setter
        that uses <code>node.getStroke()</code> and <code>node.setStroke( stroke )</code>. <code>node.hasStroke()</code>
        is also available as a quick check, and a null stroke is interpreted as not having a stroke.
      </p>
      <p>
        <code>stroke</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>),
        a <a href="#color">Color</a> object, or an instance of a
        <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
        <a href="#pattern">Pattern</a>.
      </p>
      <p>
        If a <a href="#color">Color</a> object is used for a stroke, any changes to the Color object will update this node.
      </p>

      <h4 id="strokable-lineWidth">lineWidth</h4>
      <p>
        <code>node.lineWidth</code> (<code>node.getLineWidth()</code>, <code>node.setLineWidth( lineWidth )</code>)
        controls the thickness of the stroke.
      </p>

      <h4 id="strokable-lineCap">lineCap</h4>
      <p>
        <code>node.lineCap</code> (<code>node.getLineCap()</code>, <code>node.setLineCap( lineCap )</code>)
        controls the shape of end-caps, and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linecap">Canvas lineCap definitions</a> of <code>'butt'</code> (default),
        <code>'round'</code> and <code>'square'</code>.
      </p>
      <div id="example-lineCap" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineCap', function( scene ) {
scene.addChild( new scenery.Text( 'butt', {
  fontSize: 14,
  centerX: 256/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'square', {
  fontSize: 14,
  centerX: 256*3/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'round', {
  fontSize: 14,
  centerX: 256*5/6,
  y: 20
} ) );
/*START*/
var shape = kite.Shape.lineSegment( 0, 50, 0, 70 );
scene.addChild( new scenery.Path( shape, {
  x: 256/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'butt'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*3/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'square'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*5/6,
  stroke: '#000',
  lineWidth: 30,
  lineCap: 'round'
} ) );
/*END*/
// add a red highlight
scene.addChild( new scenery.Path( shape, {
  x: 256/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*3/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*5/6,
  stroke: '#f00'
} ) );
} );
      </script>

      <h4 id="strokable-lineJoin">lineJoin</h4>
      <p>
        <code>node.lineJoin</code> (<code>node.getLineJoin()</code>, <code>node.setLineJoin( lineJoin )</code>)
        controls the shape of segment joins, and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linejoin">Canvas lineJoin definitions</a> of <code>'miter'</code> (default),
        <code>'round'</code> and <code>'bevel'</code>.
      </p>
      <div id="example-lineJoin" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineJoin', function( scene ) {
scene.addChild( new scenery.Text( 'miter', {
  fontSize: 14,
  centerX: 256/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'bevel', {
  fontSize: 14,
  centerX: 256*3/6,
  y: 20
} ) );
scene.addChild( new scenery.Text( 'round', {
  fontSize: 14,
  centerX: 256*5/6,
  y: 20
} ) );
/*START*/
var shape = new kite.Shape().moveTo( -30, 80 ).lineTo( 0, 50 ).lineTo( 30, 80 );
scene.addChild( new scenery.Path( shape, {
  x: 256/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'miter'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*3/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'bevel'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*5/6,
  stroke: '#000',
  lineWidth: 25,
  lineJoin: 'round'
} ) );
/*END*/
// add a red highlight
scene.addChild( new scenery.Path( shape, {
  x: 256/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*3/6,
  stroke: '#f00'
} ) );
scene.addChild( new scenery.Path( shape, {
  x: 256*5/6,
  stroke: '#f00'
} ) );
} );
      </script>

      <h4 id="strokable-lineDash">lineDash</h4>
      <p>
        <code>node.lineDash</code> (<code>node.getLineDash()</code>, <code>node.setLineDash( lineDash )</code>)
        controls any dashing of the stroke (or null for no dashing), and uses the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-setlinedash">Canvas setLineDash</a> handling
        as an even-length array of dash lengths.
      </p>

      <div id="example-lineDash" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineDash', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( kite.Shape.regularPolygon( 6, 25 ), {
  x: 32, y: 32,
  stroke: '#000',
  lineWidth: 3,
  lineDash: [ 10, 5 ]
} ) );
/*END*/
} );
      </script>

      <h4 id="strokable-lineDashOffset">lineDashOffset</h4>
      <p>
        <code>node.lineDashOffset</code> (<code>node.getLineDashOffset()</code>, <code>node.setLineDashOffset( lineDashOffset )</code>)
        controls the how far the dash pattern in <a href="#strokable-lineDash">lineDash</a> is offset from the start,
        same as the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linedashoffset">Canvas lineDashOffset</a>.
      </p>

      <div id="example-lineDashOffset" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-lineDashOffset', function( scene ) {
scene.addChild( new scenery.Path( new kite.Shape().moveTo( 0, 16.5 )
                                                  .lineTo( 128, 16.5 )
                                                  .moveTo( 0, 32.5 )
                                                  .lineTo( 128, 32.5 )
                                                  .moveTo( 0, 48.5 )
                                                  .lineTo( 128, 48.5 ), {
  stroke: '#f00'
} ) );
/*START*/
var shape = kite.Shape.lineSegment( 0, 0, 128, 0 );
var args = {
  stroke: '#000',
  lineWidth: 8,
  lineDash: [ 20, 5 ]
};
scene.addChild( new scenery.Path( shape, _.extend( {
  y: 16.5,
  lineDashOffset: 0
}, args ) ) );
scene.addChild( new scenery.Path( shape, _.extend( {
  y: 32.5,
  lineDashOffset: 5
}, args ) ) );
scene.addChild( new scenery.Path( shape, _.extend( {
  y: 48.5,
  lineDashOffset: 10
}, args ) ) );
/*END*/
} );
      </script>

      <h4 id="strokable-strokePickable">strokePickable</h4>
      <p>
        <code>node.strokePickable</code> is a getter/setter linked to <code>node.isStrokePickable()</code> and <code>node.setStrokePickable( boolean )</code>.
        <a href="#path">Paths</a> or other <a href="#strokable">Strokable</a> objects will be considered to be under a <a href="#pointer">Pointer</a> when
        it is over the region where the stroke is painted. This defaults to false, as it is generally more computationally expensive, and Scenery did not
        support this initially.
      </p>
      <p>
        NOTE: <a href="#text">Text</a> nodes currently do not respect this setting, since there is no easy/fast way of determining whether a point is inside
        or outside of a Text node's painted region.
      </p>

      <h3 id="path" class="section">Path</h3>
      <p>
        Path is a <a href="#node">Node</a> subtype that includes the <a href="#fillable">Fillable</a> and
        <a href="#strokable">Strokable</a> mixins. The main displayed behavior is controlled by its single
        additional option <a href="#path-shape">shape</a> along with the <a href="#fillable-fill">fill</a>
        and <a href="#strokable-stroke">stroke</a> options.
      </p>
      <p>
        A path is constructed with <code>new scenery.Path( options )</code>, where <code>options</code>
        is the standard <a href="#node">Node</a> parameter object, where the <a href="#path-shape">shape</a>
        should be specified.
      </p>

      <h4 id="path-shape">shape</h4>
      <p>
        <code>node.shape</code> (<code>node.getShape()</code>, <code>node.setShape( shape )</code>)
        controls the shape of this path, and is either an instance of <a href="../../kite">Kite</a>'s
        <a href="../../kite/doc#shape">Shape</a>, or it is a string representing an <a href="http://www.w3.org/TR/SVG/paths.html#DAttribute">SVG path</a>,
        and will be converted into a <a href="../../kite/doc#shape">Shape</a>.
      </p>

      <h3 id="image" class="section">Image</h3>
      <p>
        Image is a <a href="#node">Node</a> subtype that displays a single image in either Canvas,
        SVG or DOM. An image node is constructed with <code>new scenery.Image( image, [options] )</code>,
        where <code>image</code> is as described in <a href="#image-image">image</a>, and
        <code>options</code> is the normal <a href="#node-options">options parameter object</a>.
      </p>
      <div id="example-image" class="exampleScene" style="width: 130px; height: 85px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-image', function( scene ) {
var url = 'http://phet.colorado.edu/sims/my-solar-system/my-solar-system-thumbnail.png';
/*START*/
scene.addChild( new scenery.Image( url ) );
/*END*/
scene.updateOnRequestAnimationFrame();
} );
      </script>

      <h4 id="image-image">image</h4>
      <p>
        <code>node.image</code> (<code>node.getImage()</code>, <code>node.setImage( image )</code>)
        gets or sets the 'image' of the Image node. It can be one of the following:
      </p>
      <ul>
        <li>
          A <strong>String</strong>, treated as a URL and loads the image. <strong>Bounds-based mutators
          like <a href="#node-left">left</a> and <a href="#node-centerY">centerY</a> will not work</strong>,
          since the image will not have the correct dimensions on node construction.
        </li>
        <li>
          A <strong>HTMLImageElement</strong> will be used directly. If the image is not loaded yet,
          the bounds-based mutators (as noted above for the String case) will not work properly.
        </li>
        <li>
          A <strong>HTMLCanvasElement</strong> can also be used, but will force the node to use
          a Canvas renderer.
        </li>
      </ul>

      <h3 id="text" class="section">Text</h3>
      <p>
        Text is a <a href="#node">Node</a> subtype that (currently) displays a single line of text
        in Canvas or SVG. DOM and multiline support is planned. It also mixes in
        <a href="#fillable">Fillable</a>, and <a href="#strokable">Strokable</a>,
        so it should support fills and strokes with colors, gradients and patterns.
        The default fill is <code>'#000'</code>, so text is black by default, with no stroke, so
        to JUST stroke text, set fill to null.
      </p>
      <p>
        Text nodes are constructed with <code>new scenery.Text( text, [options] )</code>, where
        <code>text</code> is described by <a href="#text-text">text</a>, and <code>options</code>
        is the standard <a href="#node">Node</a> parameter object.
      </p>
      <div id="example-text" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-text', function( scene ) {
/*START*/
scene.addChild( new scenery.Text( 'Some text', {
  font: '20px sans-serif',
  centerX: 128, centerY: 32
} ) );
/*END*/
} );
      </script>

      <h4 id="text-options">Text Options</h4>
      <p>
        A <a href="#text">Text</a> node has the following parameter object options, in addition to
        the ones from <a href="#fillable">Fillable</a> and <a href="#strokable">Strokable</a>.
      </p>
      <ul>
        <li><a href="#text-text">text</a></li>
        <li><a href="#text-font">font</a></li>
        <li><a href="#text-fontWeight">fontWeight</a></li>
        <li><a href="#text-fontFamily">fontFamily</a></li>
        <li><a href="#text-fontStretch">fontStretch</a></li>
        <li><a href="#text-fontStyle">fontStyle</a></li>
        <li><a href="#text-fontSize">fontSize</a></li>
        <li><a href="#text-lineHeight">lineHeight</a></li>
        <li><a href="#text-textAlign">textAlign</a></li>
        <li><a href="#text-textBaseline">textBaseline</a></li>
        <li><a href="#text-direction">direction</a></li>
      </ul>

      <h4 id="text-text">text</h4>
      <p>
        <code>node.text</code> (<code>node.getText()</code>, <code>node.setText( string )</code>)
        gets or sets the string text.
      </p>

      <h4 id="text-font">font</h4>
      <p>
        <code>node.font</code> (<code>node.getFont()</code>, <code>node.setFont( font )</code>)
        gets or sets the entire font. This can be a <a href="#font">Font</a> object, or a String
        that is interpreted as a <a href="http://www.w3.org/TR/css3-fonts/">CSS font</a>.
      </p>
      <p>
        Note that Canvas places <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-font">restrictions</a> on the possible interpreted values, so
        only those should be set on a <a href="#text">Text</a> node.
      </p>

      <h4 id="text-fontWeight">fontWeight</h4>
      <p>
        <code>node.fontWeight</code> (<code>node.getFontWeight()</code>, <code>node.setFontWeight( weight )</code>)
        gets or sets the <a href="#font-weight">font weight</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-fontFamily">fontFamily</h4>
      <p>
        <code>node.fontFamily</code> (<code>node.getFontFamily()</code>, <code>node.setFontFamily( family )</code>)
        gets or sets the <a href="#font-family">font family</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-fontStretch">fontStretch</h4>
      <p>
        <code>node.fontStretch</code> (<code>node.getFontStretch()</code>, <code>node.setFontStretch( stretch )</code>)
        gets or sets the <a href="#font-stretch">font stretch</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-fontStyle">fontStyle</h4>
      <p>
        <code>node.fontStyle</code> (<code>node.getFontStyle()</code>, <code>node.setFontStyle( style )</code>)
        gets or sets the <a href="#font-style">font style</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-fontSize">fontSize</h4>
      <p>
        <code>node.fontSize</code> (<code>node.getFontSize()</code>, <code>node.setFontSize( size )</code>)
        gets or sets the <a href="#font-size">font size</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-lineHeight">lineHeight</h4>
      <p>
        <code>node.lineHeight</code> (<code>node.getLineHeight()</code>, <code>node.setLineHeight( lineHeight )</code>)
        gets or sets the <a href="#font-lineHeight">line height</a> by internally forwarding to the <a href="#text">Text</a> node's
        internal <a href="#font">Font</a> reference.
      </p>
      <p>
        Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
      </p>

      <h4 id="text-direction">direction</h4>
      <p>
        <code>node.direction</code> (<code>node.getDirection()</code>, <code>node.setDirection( direction )</code>)
        sets the LTR or RTL direction of the text. It should take on values from
        Canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-direction">context.direction</a>, but <strong>proper bounds and renderer compatibility is not ensured yet</strong>
      </p>

      <h4 id="text-boundsMethod">boundsMethod</h4>
      <p>
        <code>node.boundsMethod</code> (<code>node.getBoundsMethod()</code>, <code>node.setBoundsMethod( method )</code>)
        sets what type of method is used for determining Text bounds. Currently, there are three options: <code>"fast"</code>
        which may be somewhat inaccurate, is much faster, and disables Canvas rendering entirely, <code>"fastCanvas"</code> (default)
        which is similar but allows Canvas rendering but with dirty region redrawing disabled, or <code>"accurate"</code>
        which is accurate and supports dirty regions, but is much slower.
      </p>

      <h3 id="htmlText" class="section">HTMLText</h3>
      <p>
        HTMLText behaves exactly like <a href="#text">Text</a>, except that it displays the text as unescaped HTML.
        It will force the DOM renderer (possibly it might also allow the SVG renderer with foreignObject in the future).
        The <code>"accurate"</code> <a href="#text-boundsMethod">boundsMethod</a> is also disallowed, since using
        Canvas for HTML bounds would be extremely inaccurate.
      </p>

      <div id="example-htmlText" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-htmlText', function( scene ) {
/*START*/
scene.addChild( new scenery.HTMLText( '<strong>bold</strong>, <em>italic</em>', {
  font: '20px sans-serif',
  centerX: 128, centerY: 32,
} ) );
/*END*/
} );
      </script>

      <h3 id="dom" class="section">DOM</h3>
      <p>
        DOM is a subtype of <a href="#node">Node</a> that positions a DOM element inside the scene using
        <a href="http://www.w3.org/TR/css3-transforms/">CSS transforms</a>. If the element is attached somewhere
        else, it will be removed and added into the DOM within the <a href="#scene">scene</a>'s container
        block-level element.
      </p>
      <p>
        DOM nodes should be constructed by passing in the DOM element, along with a parameter object if desired:
        <code>new scenery.DOM( element, [options] )</code>
      </p>
      <div id="example-dom" class="exampleScene" style="width: 256px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-dom', function( scene ) {
/*START*/
var element = document.createElement( 'span' );
element.innerHTML = '<label style="display: inline;">Type in me: </label><input type="text">';
scene.addChild( new scenery.DOM( element, { x: 30, rotation: Math.PI / 6 } ) );
/*END*/
} );
      </script>

      <h4 id="dom-element">element</h4>
      <p>
        <code>node.element</code> (<code>node.getElement()</code>, <code>node.setElement( domElement )</code>)
        controls the displayed DOM element. If the element is a block-level element, it should have a specified
        width and height.
      </p>

      <h4 id="dom-interactive">interactive</h4>
      <p>
        <code>node.interactive</code> (<code>node.getInteractive()</code>, <code>node.setInteractive( boolean )</code>),
        when set to true, will signal to Scenery's event system that preventDefault() should not be called
        on DOM events when the DOM node is the event target.
      </p>


      <h3 id="linearGradient" class="section">LinearGradient</h3>
      <p>
        A LinearGradient can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        LinearGradient is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createlineargradient">context.createLinearGradient</a>, with
        <code>new scenery.LinearGradient( x0, y0, x1, y1 )</code> where the gradient goes from (x0,y0) to
        (x1,y1), and then <a href="#linearGradient-addColorStop">color stops</a> can be added.
      </p>
      <div id="example-linearGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-linearGradient', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( kite.Shape.rectangle( 0, 0, 128, 128 ), {

  // upper-left to lower-right
  fill: new scenery.LinearGradient( 0, 0, 128, 128 )
                   .addColorStop( 0, '#888' )
                   .addColorStop( 0.4, '#000' )
                   .addColorStop( 1, '#555' )
} ) );
scene.addChild( new scenery.Text( 'A', {
  fontSize: 80,
  centerX: 64, centerY: 64,

  // left to right
  fill: new scenery.LinearGradient( 0, 0, 55, 0 )
                   .addColorStop( 0, '#f00' )
                   .addColorStop( 1, '#ff0' )
} ) );
/*END*/
} );
      </script>

      <h4 id="linearGradient-addColorStop">addColorStop( <span class="args">ratio, color</span> )</h4>
      <p>
        Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
        a ratio of 1 is a color point at (x1,y1).
      </p>

      <h4 id="linearGradient-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>

      <h3 id="radialGradient" class="section">RadialGradient</h3>
      <p>
        A RadialGradient can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        RadialGradient is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createradialgradient">context.createRadialGradient</a>, with
        <code>new scenery.RadialGradient( x0, y0, r0, x1, y1, r1 )</code> where the gradient handled between
        two circles, one centered at (x0,y0) with a radius r0, and the other at (x1,y1) with a radius r1.
        Due to SVG compatibility, this is slightly constricted, as the smaller circle needs to be completely
        within the larger circle. Then <a href="#radialGradient-addColorStop">color stops</a> can be added.
      </p>
      <p>
        <strong>NOTE: Firefox 19 (Win 7) does not currently render "conic" radial gradients correctly (where x0 != x1 or y0 != y1).</strong>
        This does not appear to be the case with Firefox 19 on Mac, but please refrain from those edge-case gradients.
      </p>
      <div id="example-radialGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-radialGradient', function( scene ) {
/*START*/
scene.addChild( new scenery.Path( kite.Shape.rectangle( 0, 0, 128, 128 ), {

  // starts at a 10-px radius circle and expands out nonuniformly
  fill: new scenery.RadialGradient( 32, 32, 10, 64, 64, 90 )
                   .addColorStop( 0, '#05f' )
                   .addColorStop( 0.5, '#306' )
                   .addColorStop( 1, '#000' )
} ) );

var transparent = 'rgba(255,255,255,0)';
var letter = '#fff';
scene.addChild( new scenery.Text( 'A', {
  fontSize: 80,
  centerX: 64, centerY: 64,

  // concentric circles
  fill: new scenery.RadialGradient( 25, -30, 0, 25, -30, 50 )
                   .addColorStop( 0, transparent )
                   .addColorStop( 0.1, letter )
                   .addColorStop( 0.2, transparent )
                   .addColorStop( 0.3, letter )
                   .addColorStop( 0.4, transparent )
                   .addColorStop( 0.5, letter )
                   .addColorStop( 0.6, transparent )
                   .addColorStop( 1, letter )
} ) );
/*END*/
} );
      </script>

      <h4 id="radialGradient-addColorStop">addColorStop( <span class="args">ratio, color</span> )</h4>
      <p>
        Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
        a ratio of 1 is a color point at (x1,y1).
      </p>

      <h4 id="radialGradient-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>

      <h3 id="pattern" class="section">Pattern</h3>
      <p>
        A Pattern can be used in place of a color for any <a href="#fillable-fill">fill</a> or
        <a href="#strokable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
      </p>
      <p>
        Pattern is constructed and used very similarly to Canvas's
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createpattern">context.createPattern</a>, with
        <code>new scenery.Pattern( image )</code> where <code>image</code> is an HTMLImageElement.
      </p>
      <div id="example-pattern" class="exampleScene" style="width: 256px; height: 256px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-pattern', function( scene ) {
var loadedImg = document.createElement( 'img' );
loadedImg.addEventListener( 'load', function() {
/*START*/
scene.addChild( new scenery.Path( kite.Shape.roundRectangle( 10, 10, 236, 236, 64, 64 ), {

  // tile the image, and rotate it 30 degrees, and scale it down
  fill: new scenery.Pattern( loadedImg ).setTransformMatrix(
    dot.Matrix3.rotation2( Math.PI / 6 )
               .timesMatrix( dot.Matrix3.scale( 0.5 ) ) ),
  stroke: '#000'
} ) );
/*END*/
scene.updateScene();
} );
loadedImg.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
// loadedImg.src = 'http://phet.colorado.edu/sims/plate-tectonics/plate-tectonics-thumbnail.png';
} );
      </script>

      <h4 id="pattern-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>
      <p>
        Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
        the gradient as it is applied. This should only be done before adding it as a fill/stroke to
        any nodes.
      </p>

      <h3 id="vbox" class="section">VBox</h3>

      <h3 id="rectangle" class="section">Rectangle</h3>
      <p>
        Rectangle is a subtype of <a href="#path">Path</a> that is more convenient to construct
        and modify, and contains more optimized drawing routines for Canvas and SVG.
      </p>
      <p>
        A Rectangle is normally created with <code>new scenery.Rectangle( x, y, width, height, [options] )</code>,
        but rounded corners can be specified with <code>new scenery.Rectangle( x, y, width, height, arcWidth, arcHeight, [options] )</code>,
        or all of the parameters can be specified in the options with
        <code>new scenery.Rectangle( { rectX: _, rectY: _, rectWidth: _, rectHeight: _, ... } )</code>
      </p>
      <div id="example-rectangle" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-rectangle', function( scene ) {
/*START*/
// red rectangle
scene.addChild( new scenery.Rectangle( 10, 10, 44, 44, {
  fill: '#f00',
} ) );

// green rotated rectangle
var s = 44 / Math.sqrt( 2 );
scene.addChild( new scenery.Rectangle( -s / 2, -s / 2, s, s, {
  fill: '#0f0',
  x: 32, y: 32,
  rotation: Math.PI / 4
} ) );

// blue rectangle with 10px rounded corners
scene.addChild( new scenery.Rectangle( 74, 10, 44, 44, 10, 10, {
  fill: '#00f',
} ) );
/*END*/
} );
      </script>

      <h4 id="rectangle-rectX">rectX</h4>
      <p>
        <code>node.rectX</code> (<code>node.getRectX()</code>, <code>node.setRectX( x )</code>)
        retrieves or modifies the 'x' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h4 id="rectangle-rectY">rectY</h4>
      <p>
        <code>node.rectY</code> (<code>node.getRectY()</code>, <code>node.setRectY( y )</code>)
        retrieves or modifies the 'y' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h4 id="rectangle-rectWidth">rectWidth</h4>
      <p>
        <code>node.rectWidth</code> (<code>node.getRectWidth()</code>, <code>node.setRectWidth( width )</code>)
        retrieves or modifies the 'width' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h4 id="rectangle-rectHeight">rectHeight</h4>
      <p>
        <code>node.rectHeight</code> (<code>node.getRectHeight()</code>, <code>node.setRectHeight( height )</code>)
        retrieves or modifies the 'height' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h4 id="rectangle-rectArcWidth">rectArcWidth</h4>
      <p>
        <code>node.rectArcWidth</code> (<code>node.getRectArcWidth()</code>, <code>node.setRectArcWidth( arcWidth )</code>)
        retrieves or modifies the 'width' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h4 id="rectangle-rectArcHeight">rectArcHeight</h4>
      <p>
        <code>node.rectArcHeight</code> (<code>node.getRectArcHeight()</code>, <code>node.setRectArcHeight( arcHeight )</code>)
        retrieves or modifies the 'height' parameter of the <a href="#rectangle">Rectangle</a>.
      </p>

      <h3 id="circle" class="section">Circle</h3>
      <p>
        Circle is a subtype of <a href="#path">Path</a> that is more convenient to construct
        and modify, and contains more optimized drawing routines for SVG.
      </p>
      <p>
        A Circle is created with <code>new scenery.Circle( radius, [options] )</code> with the specified radius.
      </p>
      <div id="example-circle" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-circle', function( scene ) {
/*START*/
scene.addChild( new scenery.Circle( 22, {
  x: 32, y: 32, fill: '#f00'
} ) );
scene.addChild( new scenery.Circle( 11, {
  x: 43, y: 32, fill: '#0f0'
} ) );
/*END*/
} );
      </script>

      <h4 id="circle-radius">radius</h4>
      <p>
        <code>node.radius</code> (<code>node.getRadius()</code>, <code>node.setRadius( radius )</code>)
        retrieves or modifies the 'radius' parameter of the <a href="#circle">Circle</a>.
      </p>

      <h3 id="line" class="section">Line</h3>
      <p>
        Line is a subtype of <a href="#path">Path</a> that is more convenient to construct
        and modify, and contains more optimized drawing routines for SVG.
      </p>
      <p>
        A Line is created with <code>new scenery.Line( x1, y1, x2, y2, [options] )</code> as a line from (x1,y1) to (x2,y2). Additionally,
        the constructors <code>new scenery.Line( new Vector2( x1, y1 ), new Vector2( x2, y2 ), [options] )</code> and
        <code>new scenery.Line( { x1: x1, y1: y1, x2: x2, y2: y2, [other options] } )</code>
        are supported.
      </p>
      <div id="example-line" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
      <script type="text/javascript">
docExample( 'example-line', function( scene ) {
/*START*/
scene.addChild( new scenery.Line( 8, 8, 56, 56, {
  stroke: 'red', lineWidth: 5, lineCap: 'round'
} ) );
scene.addChild( new scenery.Line( 8, 56, 56, 8, {
  stroke: 'blue', lineWidth: 5, lineCap: 'round'
} ) );
/*END*/
} );
      </script>

      <h4 id="line-x1">x1</h4>
      <p>
        <code>node.x1</code> (<code>node.getX1()</code>, <code>node.setX1( x1 )</code>)
        retrieves or modifies the 'x1' parameter of the <a href="#line">Line</a>.
      </p>
      <h4 id="line-y1">y1</h4>
      <p>
        <code>node.y1</code> (<code>node.getY1()</code>, <code>node.setY1( y1 )</code>)
        retrieves or modifies the 'y1' parameter of the <a href="#line">Line</a>.
      </p>
      <h4 id="line-x2">x2</h4>
      <p>
        <code>node.x2</code> (<code>node.getX2()</code>, <code>node.setX2( x2 )</code>)
        retrieves or modifies the 'x2' parameter of the <a href="#line">Line</a>.
      </p>
      <h4 id="line-y2">y2</h4>
      <p>
        <code>node.y2</code> (<code>node.getY2()</code>, <code>node.setY2( y2 )</code>)
        retrieves or modifies the 'y2' parameter of the <a href="#line">Line</a>.
      </p>
      <h4 id="line-p1">p1</h4>
      <p>
        <code>node.p1</code> (<code>node.getPoint1()</code>, <code>node.setPoint1( p1 )</code>)
        retrieves or modifies the Vector2 (x1,y1) of the <a href="#line">Line</a>.
      </p>
      <h4 id="line-p2">p2</h4>
      <p>
        <code>node.p2</code> (<code>node.getPoint2()</code>, <code>node.setPoint2( p2 )</code>)
        retrieves or modifies the Vector2 (x2,y2) of the <a href="#line">Line</a>.
      </p>

      <h3 id="font" class="section">Font</h3>
      <p>
        Font represents a single <strong>immutable</strong>font, which can be queried for various parameters, and can be changed.
      </p>
      <p>
        It can be constructed with <code>new scenery.Font()</code> initialized with the default font '10px sans-serif',
        <code>new scenery.Font( cssFontString )</code> initialized with the specified <a href="http://www.w3.org/TR/css3-fonts/">CSS Font</a>,
        or with a property object <code>new scenery.Font( { ... } )</code>, where any of the Font's properties
        (<a href="#font-font">font</a>, <a href="#font-family">family</a>, <a href="#font-weight">weight</a>, <a href="#font-stretch">stretch</a>, <a href="#font-style">style</a>, <a href="#font-size">size</a>, and <a href="#font-lineHeight">lineHeight</a>)
        can be present.
      </p>
      <p>
        For example, <code>new scenery.Font( { size: 16, style: 'italic' } )</code> and <code>new scenery.Font( 'italic 16px sans-serif' )</code>
        are equivalent ways of creating that specific Font instance. In addition:
      </p>
      <pre class="brush: js">
new scenery.Font().font                      // "10px sans-serif" (the default)
new scenery.Font( { family: 'serif' } ).font // "10px serif"
new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
var font = new scenery.Font( {
  family: '"Times New Roman", serif',
  style: 'italic',
  lineHeight: 10
} );
font.font;                                   // "italic 10px/10 'Times New Roman', serif"
font.family;                                 // "'Times New Roman', serif"
font.weight;                                 // 400 (the default)
      </pre>

      <h4 id="font-font">font</h4>
      <p>
        <code>font.font</code> (<code>font.getFont()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font">shorthand CSS 'font' property</a> of the Font object.
        This property completely specifies all font settings.
      </p>

      <h4 id="font-family">family</h4>
      <p>
        <code>font.family</code> (<code>font.getFamily()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-family">CSS 'font-family' property</a> of the Font object.
      </p>

      <h4 id="font-weight">weight</h4>
      <p>
        <code>font.weight</code> (<code>font.getWeight()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-weight">CSS 'font-weight' property</a> of the Font object.
      </p>

      <h4 id="font-stretch">stretch</h4>
      <p>
        <code>font.stretch</code> (<code>font.getStretch()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-stretch">CSS 'font-stretch' property</a> of the Font object.
      </p>

      <h4 id="font-style">style</h4>
      <p>
        <code>font.style</code> (<code>font.getStyle()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-style">CSS 'font-style' property</a> of the Font object.
      </p>

      <h4 id="font-size">size</h4>
      <p>
        <code>font.size</code> (<code>font.getSize()</code>)
        retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-size">CSS 'font-size' property</a> of the Font object.
      </p>

      <h4 id="font-lineHeight">lineHeight</h4>
      <p>
        <strong>Deprecated</strong>: <code>font.lineHeight</code> (<code>font.getLineHeight()</code>)
        retrieves the <a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-line-height">CSS 'line-height' property</a> of the Font object.
      </p>


      <h3 id="color" class="section">Color</h3>
      <p>
        A Color can be constructed either with any valid CSS color (<code>new scenery.Color( cssColorString )</code>), or with components directly
        (<code>new scenery.Color( red, green blue [, alpha] )</code>) where red/green/blue are 0-255, and alpha is 0-1.
      </p>
      <p>Color operations will assume that the color is not pre-multiplied.</p>

      <h4 id="color-red">red</h4>
      <p>
        <code>color.red</code> (<code>color.getRed()</code>, <code>color.setRed( redInt )</code>)
        retrieves or modifies the red component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
      </p>

      <h4 id="color-green">green</h4>
      <p>
        <code>color.green</code> (<code>color.getGreen()</code>, <code>color.setGreen( greenInt )</code>)
        retrieves or modifies the green component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
      </p>

      <h4 id="color-blue">blue</h4>
      <p>
        <code>color.blue</code> (<code>color.getBlue()</code>, <code>color.setBlue( blueInt )</code>)
        retrieves or modifies the blue component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
      </p>

      <h4 id="color-alpha">alpha</h4>
      <p>
        <code>color.alpha</code> (<code>color.getAlpha()</code>, <code>color.setAlpha( alphaFloat )</code>)
        retrieves or modifies the alpha component of the color. It will be returned or converted to an integral value between 0-1 (inclusive).
      </p>

      <h4 id="color-toCSS">toCSS()</h4>
      <p>
        Returns a CSS value for the color, currently using 'rgb' or 'rgba'.
      </p>


      <h3 id="event" class="section">Event</h3>
      <h3 id="pointer" class="section">Pointer</h3>
      <h3 id="mouse" class="section">Mouse</h3>
      <h3 id="touch" class="section">Touch</h3>
      <h3 id="pen" class="section">Pen</h3>
      <h3 id="trail" class="section">Trail</h3>

    </div>
    <div class="span3"></div>
  </div>

  <script type="text/javascript">
    SyntaxHighlighter.all();
  </script>
</body>
</html>
